{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MarkdownUtil_1 = require(\"../util/MarkdownUtil\");\n/**\n * Inserts insertionString before each line\n */\n\n\nfunction insertBeforeEachLine(selectedText, insertBefore) {\n  var lines = selectedText.split(/\\n/);\n  var insertionLength = 0;\n  var modifiedText = lines.map(function (item, index) {\n    if (typeof insertBefore === \"string\") {\n      insertionLength += insertBefore.length;\n      return insertBefore + item;\n    } else if (typeof insertBefore === \"function\") {\n      var insertionResult = insertBefore(item, index);\n      insertionLength += insertionResult.length;\n      return insertBefore(item, index) + item;\n    }\n\n    throw Error(\"insertion is expected to be either a string or a function\");\n  }).join(\"\\n\");\n  return {\n    modifiedText: modifiedText,\n    insertionLength: insertionLength\n  };\n}\n\nexports.insertBeforeEachLine = insertBeforeEachLine;\n\nexports.makeList = function (state0, api, insertBefore) {\n  // Adjust the selection to encompass the whole word if the caret is inside one\n  var newSelectionRange = MarkdownUtil_1.selectWord({\n    text: state0.text,\n    selection: state0.selection\n  });\n  var state1 = api.setSelectionRange(newSelectionRange);\n  var breaksBeforeCount = MarkdownUtil_1.getBreaksNeededForEmptyLineBefore(state1.text, state1.selection.start);\n  var breaksBefore = Array(breaksBeforeCount + 1).join(\"\\n\");\n  var breaksAfterCount = MarkdownUtil_1.getBreaksNeededForEmptyLineAfter(state1.text, state1.selection.end);\n  var breaksAfter = Array(breaksAfterCount + 1).join(\"\\n\");\n  var modifiedText = insertBeforeEachLine(state1.selectedText, insertBefore);\n  api.replaceSelection(\"\" + breaksBefore + modifiedText.modifiedText + breaksAfter); // Specifically when the text has only one line, we can exclude the \"- \", for example, from the selection\n\n  var oneLinerOffset = state1.selectedText.indexOf(\"\\n\") === -1 ? modifiedText.insertionLength : 0;\n  var selectionStart = state1.selection.start + breaksBeforeCount + oneLinerOffset;\n  var selectionEnd = selectionStart + modifiedText.modifiedText.length - oneLinerOffset; // Adjust the selection to not contain the **\n\n  api.setSelectionRange({\n    start: selectionStart,\n    end: selectionEnd\n  });\n};\n\nexports.unorderedListCommand = {\n  name: \"unordered-list\",\n  buttonProps: {\n    \"aria-label\": \"Add unordered list\"\n  },\n  execute: function execute(state0, api) {\n    exports.makeList(state0, api, \"- \");\n  },\n  keyCommand: \"code\"\n};\nexports.orderedListCommand = {\n  name: \"ordered-list\",\n  buttonProps: {\n    \"aria-label\": \"Add ordered list\"\n  },\n  execute: function execute(state0, api) {\n    exports.makeList(state0, api, function (item, index) {\n      return index + 1 + \". \";\n    });\n  },\n  keyCommand: \"code\"\n};\nexports.checkedListCommand = {\n  name: \"checked-list\",\n  buttonProps: {\n    \"aria-label\": \"Add checked list\"\n  },\n  execute: function execute(state0, api) {\n    exports.makeList(state0, api, function (item, index) {\n      return \"- [ ] \";\n    });\n  },\n  keyCommand: \"code\"\n};","map":null,"metadata":{},"sourceType":"script"}